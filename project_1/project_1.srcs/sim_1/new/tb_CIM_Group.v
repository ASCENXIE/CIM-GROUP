`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2025/11/12 21:43:19
// Design Name: 
// Module Name: tb_CIM_Group
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: this is a simple testbench for CIM_Group, input and output is generated by python script.
// Input data width is 512bit, and is transferred by bus. 
// The module needs to configure Cluster, Group, Layer, Kernel, Stride and feature width before input data. 
// 1.set feature width = 16
// 2.set feature height = 4
// 3.set Cluster = 0, Group = 0, Layer = 0, Kernel = 3, Stride = 1
// 4.input 576 weights(512bit each), last 576 cycles, set i_Is_weight = 1
// 5.input feature data, total 16*4*8=512 cycles, each 8-cycle input 512bit feature data, set i_Is_weight = 0
// 6.when one feature map input is done, set input_done_single_flag = 1 for one clock cycle
// weight is stored in CIM as following order: first store one pixel's 64 weights and next to the same row next pixel's 64 weights...
// feature should input as following order: first input one pixel's 64 channels feature data, next to the same row next pixel's 64 channels feature data...
// 7. at cim mode, address should be 575, 575 represents activate all 576 CIM cells
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module tb_CIM_Group;
parameter PERIOD = 4;
parameter DATA_WIDTH = 512;
parameter FEATURE_H = 4;
parameter FEATURE_W = 16;
parameter OH = FEATURE_H - 3 + 1;  
parameter OW = FEATURE_W - 3 + 1;

integer i;
integer j;
integer k;
// input buffer inputs
reg clk = 0;
reg rst_n = 0;
reg en;
reg [2:0] i_Cluster_cfg = 0;
reg [2:0] i_Group_cfg = 0;
reg [2:0] i_Layer_cfg = 0;
reg [2:0] i_Kernel_cfg = 0;
reg i_Stride_cfg = 0;
reg [7:0] i_Feature_width_cfg = 0;
reg [7:0] feature_height = 4;           // feature height
reg input_done_single_flag = 0;         //when one feature map input is done, this flag will be set to 1 for one clock cycle
reg [DATA_WIDTH-1:0] i_Lane_data = 0;
reg i_Lane_vld = 0;
reg [2:0] i_Cluster_num = 0;
reg [2:0] i_Group_num = 0;
reg [2:0] i_Layer_num = 0;
reg i_Is_weight = 0;

// outputs
wire [26*64-1:0] cim_result;
wire [64*16-1:0] o_Output_data;
wire o_Output_vld;

reg [25:0] result_group [0:63][0:FEATURE_W-1][0:FEATURE_H-1]; 
reg [512-1:0] weight_mem [0:575]; 

reg [512-1:0] feature_mem [0:FEATURE_H*FEATURE_W-1];

initial begin
    $readmemh("C:/work_file/grade1/GROUP_RTL_CODE/python_verification/kernel_weights_CIM_Group.txt", weight_mem);
end

initial begin
    $readmemh("C:/work_file/grade1/GROUP_RTL_CODE/python_verification/pixel_data_CIM_Group.txt", feature_mem);
end

initial begin
    forever #(PERIOD/2) clk = ~clk;
end

initial begin
    #(PERIOD*10) rst_n = 1;
end

`ifdef FSDB
initial begin
    $fsdbDumpfile("./tb_CIM_Group.fsdb");
    $fsdbDumpvars(0);
    $fsdbDumpMDA();
end
`endif 

CIM_Group u_CIM_Group (
    .clk         (clk                           ),
    .rst_n       (rst_n                          ),
    .en          (en                            ),
    .i_Cluster_cfg   (3'd0                      ),
    .i_Group_cfg     (3'd0                      ),
    .i_Layer_cfg     (3'd0                      ),
    .i_Kernel_cfg    (3'd0                      ),
    .i_Stride_cfg    (2'd0                      ),
    .i_Feature_Width   (i_Feature_width_cfg   ),
    .i_Net_cfg       (1'b0                      ),
    .i_cfg_done     (1'b1                      ),
    .i_input_done_single_fea (input_done_single_flag  ),
    .i_Lane_data      (i_Lane_data                ),
    .i_Lane_data_vld  (i_Lane_vld                 ),     
    .i_Cluster_num   (i_Cluster_num                ),
    .i_Group_num     (i_Group_num                  ),
    .i_Layer_num     (i_Layer_num                  ),
    .i_Is_weight     (i_Is_weight                 ),
    .o_Output_data   (o_Output_data               ),
    .o_Output_vld    (o_Output_vld                ),
    .o_Cluster_num   (o_Cluster_num               ),
    .o_Group_num     (o_Group_num                 ),
    .o_Layer_num     (o_Layer_num                 ),
    .cim_result     (cim_result                   )
);


always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        en <= 1'b0;
        i_Feature_width_cfg <= FEATURE_W; // feature width = 16
        feature_height <= FEATURE_H;        // feature height = 4
        input_done_single_flag <= 1'b0;
        i_Lane_data <= 512'b0;
        i_Lane_vld <= 1'b0;
        i_Cluster_num <= 3'd0;
        i_Group_num <= 3'd0;
        i_Layer_num <= 3'd0;
        i_Is_weight <= 1'b0; // first input weight
    end
    else begin       
        en <= 1'b1;
        // input weight data
        for(i = 0; i < 576; i = i + 1) begin
            i_Lane_data <= weight_mem[i];
            i_Lane_vld <= 1'b1;
            i_Is_weight <= 1'b1;
            @(posedge clk);
        end
        // input feature data
        i_Is_weight <= 1'b0;
        for(i = 0; i < FEATURE_H*FEATURE_W; i = i + 1) begin
            i_Lane_data <= feature_mem[i];
            i_Lane_vld <= 1'b1;
            input_done_single_flag <= 1'b0;
            for (j = 0; j < 8; j = j + 1) begin
                @(posedge clk);
                i_Lane_vld <= 1'b0;
            end
        end
        @(posedge clk);
        input_done_single_flag <= 1'b1;
        i_Lane_vld <= 1'b0;
        @(posedge clk);
        input_done_single_flag <= 1'b0;
        for (j = 0; j < 1000; j = j + 1) begin
            @(posedge clk);
        end
        en <= 1'b0;
        #200;
         $finish;
    end
end

reg [9:0] i_reg, j_reg;  // 根据 FEATURE_H/W 位宽调整
reg write;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        i_reg <= 0;
        j_reg <= 0;
        write <= 0;
    end
    else if (o_Output_vld) begin
        // 写入当前位置
        for (k = 0; k < 64; k = k + 1) begin
            result_group[k][j_reg][i_reg] <= cim_result[1663-k*26 -: 26];
        end

        // 更新坐标
        if (j_reg == OW - 1) begin
            j_reg <= 0;
            if (i_reg == OH - 1) begin
                i_reg <= 0;  // 可选：循环或停止
                write <= 1;
            end else begin
                i_reg <= i_reg + 1;
            end
        end else begin
            j_reg <= j_reg + 1;
        end
    end
end

integer f;

initial begin
    f = $fopen("result_group.txt", "w");
    if (f == 0) begin
        $display("ERROR: Could not open result_group.txt");
        $finish;
    end

    // 等待你判定“写完”的时刻，比如 i_reg 和 j_reg 归零
    @(posedge clk) wait(write == 1);

    // 写入三维数组
    for (k = 0; k < OH; k = k + 1) begin
        for (j = 0; j < OW; j = j + 1) begin
            for (i = 0; i < 64; i = i + 1) begin
                $fdisplay(f, "%h", result_group[i][j][k]);
            end
        end
    end

    $fclose(f);
    $display(">>> result_group.txt write done.");
    $finish;
end


endmodule
